<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DNG SDK 1.5: dng_area_task Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DNG SDK 1.5
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classdng__area__task-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dng_area_task Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract class for rectangular processing operations with support for partitioning across multiple processing resources and observing memory constraints.  
 <a href="classdng__area__task.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dng__area__task_8h_source.html">dng_area_task.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for dng_area_task:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classdng__area__task.png" usemap="#dng_5Farea_5Ftask_map" alt=""/>
  <map id="dng_5Farea_5Ftask_map" name="dng_5Farea_5Ftask_map">
<area href="classdng__encode__proxy__task.html" alt="dng_encode_proxy_task" shape="rect" coords="238,56,466,80"/>
<area href="classdng__filter__task.html" title="Represents a task which filters an area of a source dng_image to an area of a destination dng_image." alt="dng_filter_task" shape="rect" coords="238,112,466,136"/>
<area href="classdng__find__new__raw__image__digest__task.html" alt="dng_find_new_raw_image_digest_task" shape="rect" coords="238,168,466,192"/>
<area href="classdng__inplace__opcode__task.html" alt="dng_inplace_opcode_task" shape="rect" coords="238,224,466,248"/>
<area href="classdng__jpeg__image__encode__task.html" alt="dng_jpeg_image_encode_task" shape="rect" coords="238,280,466,304"/>
<area href="classdng__jpeg__image__find__digest__task.html" alt="dng_jpeg_image_find_digest_task" shape="rect" coords="238,336,466,360"/>
<area href="classdng__limit__float__depth__task.html" alt="dng_limit_float_depth_task&lt; simd &gt;" shape="rect" coords="238,392,466,416"/>
<area href="classdng__linearize__image.html" alt="dng_linearize_image" shape="rect" coords="238,448,466,472"/>
<area href="classdng__read__tiles__task.html" alt="dng_read_tiles_task" shape="rect" coords="238,504,466,528"/>
<area href="classdng__write__tiles__task.html" alt="dng_write_tiles_task" shape="rect" coords="238,560,466,584"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a315f6f90144b986590a2f7d468b91d89"><td class="memItemLeft" align="right" valign="top"><a id="a315f6f90144b986590a2f7d468b91d89"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>dng_area_task</b> (const char *name=&quot;unnamed <a class="el" href="classdng__area__task.html">dng_area_task</a>&quot;)</td></tr>
<tr class="separator:a315f6f90144b986590a2f7d468b91d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ffc074a1abd248388b7dec94134343"><td class="memItemLeft" align="right" valign="top"><a id="a06ffc074a1abd248388b7dec94134343"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>Name</b> () const</td></tr>
<tr class="separator:a06ffc074a1abd248388b7dec94134343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae344964831e8d9fbb83feb4964af1a4b"><td class="memItemLeft" align="right" valign="top">virtual uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#ae344964831e8d9fbb83feb4964af1a4b">MaxThreads</a> () const</td></tr>
<tr class="separator:ae344964831e8d9fbb83feb4964af1a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e4ddc7ff7205307165b8e437d8e6d8"><td class="memItemLeft" align="right" valign="top">virtual uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#ac5e4ddc7ff7205307165b8e437d8e6d8">MinTaskArea</a> () const</td></tr>
<tr class="memdesc:ac5e4ddc7ff7205307165b8e437d8e6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">operation. (Partitions can be smaller due to small inputs and edge cases.)  <a href="#ac5e4ddc7ff7205307165b8e437d8e6d8">More...</a><br /></td></tr>
<tr class="separator:ac5e4ddc7ff7205307165b8e437d8e6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8112e046329c15ebe82b88d11c407575"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdng__point.html">dng_point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#a8112e046329c15ebe82b88d11c407575">UnitCell</a> () const</td></tr>
<tr class="separator:a8112e046329c15ebe82b88d11c407575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4bf912c920845bb6281ccc9aba7d0c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdng__point.html">dng_point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#aed4bf912c920845bb6281ccc9aba7d0c">MaxTileSize</a> () const</td></tr>
<tr class="separator:aed4bf912c920845bb6281ccc9aba7d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac347313703dc676464a3935523184ebe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdng__rect.html">dng_rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#ac347313703dc676464a3935523184ebe">RepeatingTile1</a> () const</td></tr>
<tr class="separator:ac347313703dc676464a3935523184ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8eaedd070231b36853df5ce10e4915"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdng__rect.html">dng_rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#a8b8eaedd070231b36853df5ce10e4915">RepeatingTile2</a> () const</td></tr>
<tr class="separator:a8b8eaedd070231b36853df5ce10e4915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa689944fe7e197b396eceac13d835b6a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdng__rect.html">dng_rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#aa689944fe7e197b396eceac13d835b6a">RepeatingTile3</a> () const</td></tr>
<tr class="separator:aa689944fe7e197b396eceac13d835b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e8c7891745cbe4e6a84600cd4304d5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#ac8e8c7891745cbe4e6a84600cd4304d5">Start</a> (uint32 threadCount, const <a class="el" href="classdng__rect.html">dng_rect</a> &amp;dstArea, const <a class="el" href="classdng__point.html">dng_point</a> &amp;tileSize, <a class="el" href="classdng__memory__allocator.html">dng_memory_allocator</a> *allocator, <a class="el" href="classdng__abort__sniffer.html">dng_abort_sniffer</a> *sniffer)</td></tr>
<tr class="separator:ac8e8c7891745cbe4e6a84600cd4304d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff21f0bc38f2833cf61e248ee884cec8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#aff21f0bc38f2833cf61e248ee884cec8">Process</a> (uint32 threadIndex, const <a class="el" href="classdng__rect.html">dng_rect</a> &amp;tile, <a class="el" href="classdng__abort__sniffer.html">dng_abort_sniffer</a> *sniffer)=0</td></tr>
<tr class="memdesc:aff21f0bc38f2833cf61e248ee884cec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">and progress updates.  <a href="#aff21f0bc38f2833cf61e248ee884cec8">More...</a><br /></td></tr>
<tr class="separator:aff21f0bc38f2833cf61e248ee884cec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bee7a806bea666b0ecca96089ab7a7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#a25bee7a806bea666b0ecca96089ab7a7">Finish</a> (uint32 threadCount)</td></tr>
<tr class="separator:a25bee7a806bea666b0ecca96089ab7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94898e6c62176efdd6b3819894368ce4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdng__point.html">dng_point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#a94898e6c62176efdd6b3819894368ce4">FindTileSize</a> (const <a class="el" href="classdng__rect.html">dng_rect</a> &amp;area) const</td></tr>
<tr class="separator:a94898e6c62176efdd6b3819894368ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80c05689fff8d30091454a4aa1aaec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#af80c05689fff8d30091454a4aa1aaec5">ProcessOnThread</a> (uint32 threadIndex, const <a class="el" href="classdng__rect.html">dng_rect</a> &amp;area, const <a class="el" href="classdng__point.html">dng_point</a> &amp;tileSize, <a class="el" href="classdng__abort__sniffer.html">dng_abort_sniffer</a> *sniffer, <a class="el" href="classdng__area__task__progress.html">dng_area_task_progress</a> *progress)</td></tr>
<tr class="separator:af80c05689fff8d30091454a4aa1aaec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72270e63cb2e5f4f685493adad00fe6e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdng__base__tile__iterator.html">dng_base_tile_iterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#a72270e63cb2e5f4f685493adad00fe6e">MakeTileIterator</a> (uint32 threadIndex, const <a class="el" href="classdng__rect.html">dng_rect</a> &amp;tile, const <a class="el" href="classdng__rect.html">dng_rect</a> &amp;area) const</td></tr>
<tr class="separator:a72270e63cb2e5f4f685493adad00fe6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002393bc9b9fc57d922ed1c5dac1f40b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdng__base__tile__iterator.html">dng_base_tile_iterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#a002393bc9b9fc57d922ed1c5dac1f40b">MakeTileIterator</a> (uint32 threadIndex, const <a class="el" href="classdng__point.html">dng_point</a> &amp;tileSize, const <a class="el" href="classdng__rect.html">dng_rect</a> &amp;area) const</td></tr>
<tr class="separator:a002393bc9b9fc57d922ed1c5dac1f40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab3b8c2eb594436fa36f8e0d36b549ed2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdng__area__task.html#ab3b8c2eb594436fa36f8e0d36b549ed2">Perform</a> (<a class="el" href="classdng__area__task.html">dng_area_task</a> &amp;task, const <a class="el" href="classdng__rect.html">dng_rect</a> &amp;area, <a class="el" href="classdng__memory__allocator.html">dng_memory_allocator</a> *allocator, <a class="el" href="classdng__abort__sniffer.html">dng_abort_sniffer</a> *sniffer, <a class="el" href="classdng__area__task__progress.html">dng_area_task_progress</a> *progress)</td></tr>
<tr class="separator:ab3b8c2eb594436fa36f8e0d36b549ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2c0b6b0a87f9fbe317a5c4c89606c558"><td class="memItemLeft" align="right" valign="top"><a id="a2c0b6b0a87f9fbe317a5c4c89606c558"></a>
uint32&#160;</td><td class="memItemRight" valign="bottom"><b>fMaxThreads</b></td></tr>
<tr class="separator:a2c0b6b0a87f9fbe317a5c4c89606c558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a66f2ddc471b65d85824c1ca36f5740"><td class="memItemLeft" align="right" valign="top"><a id="a1a66f2ddc471b65d85824c1ca36f5740"></a>
uint32&#160;</td><td class="memItemRight" valign="bottom"><b>fMinTaskArea</b></td></tr>
<tr class="separator:a1a66f2ddc471b65d85824c1ca36f5740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5baabf8937c04992b838302a2c31f3ed"><td class="memItemLeft" align="right" valign="top"><a id="a5baabf8937c04992b838302a2c31f3ed"></a>
<a class="el" href="classdng__point.html">dng_point</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fUnitCell</b></td></tr>
<tr class="separator:a5baabf8937c04992b838302a2c31f3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f041d95d057b9c169171d84c4dc886a"><td class="memItemLeft" align="right" valign="top"><a id="a0f041d95d057b9c169171d84c4dc886a"></a>
<a class="el" href="classdng__point.html">dng_point</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fMaxTileSize</b></td></tr>
<tr class="separator:a0f041d95d057b9c169171d84c4dc886a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3317dacd300a048a33fd4472cbcfddd5"><td class="memItemLeft" align="right" valign="top"><a id="a3317dacd300a048a33fd4472cbcfddd5"></a>
<a class="el" href="classdng__string.html">dng_string</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fName</b></td></tr>
<tr class="separator:a3317dacd300a048a33fd4472cbcfddd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract class for rectangular processing operations with support for partitioning across multiple processing resources and observing memory constraints. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a94898e6c62176efdd6b3819894368ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94898e6c62176efdd6b3819894368ce4">&#9670;&nbsp;</a></span>FindTileSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdng__point.html">dng_point</a> dng_area_task::FindTileSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdng__rect.html">dng_rect</a> &amp;&#160;</td>
          <td class="paramname"><em>area</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find tile size taking into account repeating tiles, unit cell, and maximum tile size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">area</td><td>Computation area for which to find tile size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Tile</td><td>size as height and width in point. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classdng__area__task.html#aed4bf912c920845bb6281ccc9aba7d0c">MaxTileSize()</a>, <a class="el" href="classdng__area__task.html#ac347313703dc676464a3935523184ebe">RepeatingTile1()</a>, <a class="el" href="classdng__area__task.html#a8b8eaedd070231b36853df5ce10e4915">RepeatingTile2()</a>, <a class="el" href="classdng__area__task.html#aa689944fe7e197b396eceac13d835b6a">RepeatingTile3()</a>, and <a class="el" href="classdng__area__task.html#a8112e046329c15ebe82b88d11c407575">UnitCell()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classdng__area__task.html#ab3b8c2eb594436fa36f8e0d36b549ed2">Perform()</a>.</p>

</div>
</div>
<a id="a25bee7a806bea666b0ecca96089ab7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25bee7a806bea666b0ecca96089ab7a7">&#9670;&nbsp;</a></span>Finish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dng_area_task::Finish </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>threadCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Task computation finalization and teardown method. Called after all resources have completed processing. Can be overridden to accumulate results and free resources allocated in Start.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadCount</td><td>Number of threads used for processing. Same as value passed to Start. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classdng__area__task.html#ab3b8c2eb594436fa36f8e0d36b549ed2">Perform()</a>.</p>

</div>
</div>
<a id="a72270e63cb2e5f4f685493adad00fe6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72270e63cb2e5f4f685493adad00fe6e">&#9670;&nbsp;</a></span>MakeTileIterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdng__base__tile__iterator.html">dng_base_tile_iterator</a> * dng_area_task::MakeTileIterator </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>threadIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdng__rect.html">dng_rect</a> &amp;&#160;</td>
          <td class="paramname"><em>tile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdng__rect.html">dng_rect</a> &amp;&#160;</td>
          <td class="paramname"><em>area</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Factory method to make a tile iterator. This iterator will be used by a thread to process tiles in an area in a specific order. The default implementation uses a forward iterator that visits tiles from left to right (inner), top down (outer). Subclasses can override this method to produce tile iterators that visit tiles in different orders.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadIndex</td><td>0 to threadCount - 1 index indicating which thread this is. </td></tr>
    <tr><td class="paramname">tile</td><td>The tile to be traversed within the tile area. </td></tr>
    <tr><td class="paramname">area</td><td>Tile area partitioned to this resource. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classdng__area__task.html#af80c05689fff8d30091454a4aa1aaec5">ProcessOnThread()</a>.</p>

</div>
</div>
<a id="a002393bc9b9fc57d922ed1c5dac1f40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002393bc9b9fc57d922ed1c5dac1f40b">&#9670;&nbsp;</a></span>MakeTileIterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdng__base__tile__iterator.html">dng_base_tile_iterator</a> * dng_area_task::MakeTileIterator </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>threadIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdng__point.html">dng_point</a> &amp;&#160;</td>
          <td class="paramname"><em>tileSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdng__rect.html">dng_rect</a> &amp;&#160;</td>
          <td class="paramname"><em>area</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Factory method to make a tile iterator. This iterator will be used by a thread to process tiles in an area in a specific order. The default implementation uses a forward iterator that visits tiles from left to right (inner), top down (outer). Subclasses can override this method to produce tile iterators that visit tiles in different orders.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadIndex</td><td>0 to threadCount - 1 index indicating which thread this is. </td></tr>
    <tr><td class="paramname">tileSize</td><td>The tile size to be traversed within the tile area. </td></tr>
    <tr><td class="paramname">area</td><td>Tile area partitioned to this resource. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae344964831e8d9fbb83feb4964af1a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae344964831e8d9fbb83feb4964af1a4b">&#9670;&nbsp;</a></span>MaxThreads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32 dng_area_task::MaxThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Getter for the maximum number of threads (resources) that can be used for processing</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Number</td><td>of threads, minimum of 1, that can be used for this task. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed4bf912c920845bb6281ccc9aba7d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4bf912c920845bb6281ccc9aba7d0c">&#9670;&nbsp;</a></span>MaxTileSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdng__point.html">dng_point</a> dng_area_task::MaxTileSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Getter for maximum size of a tile for processing. Often processing will need to allocate temporary buffers or use other resources that are either fixed or in limited supply. The maximum tile size forces further partitioning if the tile is bigger than this size.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Maximum</td><td>tile size allowed for this area task. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classdng__area__task.html#a94898e6c62176efdd6b3819894368ce4">FindTileSize()</a>.</p>

</div>
</div>
<a id="ac5e4ddc7ff7205307165b8e437d8e6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e4ddc7ff7205307165b8e437d8e6d8">&#9670;&nbsp;</a></span>MinTaskArea()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32 dng_area_task::MinTaskArea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operation. (Partitions can be smaller due to small inputs and edge cases.) </p>
<p>Getter for minimum area of a partitioned rectangle. Often it is not profitable to use more resources if it requires partitioning the input into chunks that are too small, as the overhead increases more than the speedup. This method can be ovreridden for a specific task to indicate the smallest area for partitioning. Default is 256x256 pixels.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Minimum</td><td>area for a partitoned tile in order to give performant </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3b8c2eb594436fa36f8e0d36b549ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b8c2eb594436fa36f8e0d36b549ed2">&#9670;&nbsp;</a></span>Perform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dng_area_task::Perform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdng__area__task.html">dng_area_task</a> &amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdng__rect.html">dng_rect</a> &amp;&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdng__memory__allocator.html">dng_memory_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdng__abort__sniffer.html">dng_abort_sniffer</a> *&#160;</td>
          <td class="paramname"><em>sniffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdng__area__task__progress.html">dng_area_task_progress</a> *&#160;</td>
          <td class="paramname"><em>progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default resource partitioner that assumes a single resource to be used for processing. Implementations that are aware of multiple processing resources should override (replace) this method. This is usually done in <a class="el" href="classdng__host.html#afe41065e72391fca672eaa657dca5798">dng_host::PerformAreaTask</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task to perform. </td></tr>
    <tr><td class="paramname">area</td><td>The area on which mage processing should be performed. </td></tr>
    <tr><td class="paramname">allocator</td><td><a class="el" href="classdng__memory__allocator.html" title="Interface for dng_memory_block allocator.">dng_memory_allocator</a> to use for allocating temporary buffers, etc. </td></tr>
    <tr><td class="paramname">sniffer</td><td><a class="el" href="classdng__abort__sniffer.html" title="Class for signaling user cancellation and receiving progress updates.">dng_abort_sniffer</a> to use to check for user cancellation and progress updates. </td></tr>
    <tr><td class="paramname">progress</td><td>optional pointer to progress reporting object. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classdng__area__task.html#a94898e6c62176efdd6b3819894368ce4">FindTileSize()</a>, <a class="el" href="classdng__area__task.html#a25bee7a806bea666b0ecca96089ab7a7">Finish()</a>, <a class="el" href="classdng__area__task.html#af80c05689fff8d30091454a4aa1aaec5">ProcessOnThread()</a>, and <a class="el" href="classdng__area__task.html#ac8e8c7891745cbe4e6a84600cd4304d5">Start()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classdng__host.html#afe41065e72391fca672eaa657dca5798">dng_host::PerformAreaTask()</a>.</p>

</div>
</div>
<a id="aff21f0bc38f2833cf61e248ee884cec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff21f0bc38f2833cf61e248ee884cec8">&#9670;&nbsp;</a></span>Process()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void dng_area_task::Process </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>threadIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdng__rect.html">dng_rect</a> &amp;&#160;</td>
          <td class="paramname"><em>tile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdng__abort__sniffer.html">dng_abort_sniffer</a> *&#160;</td>
          <td class="paramname"><em>sniffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>and progress updates. </p>
<p>Process one tile or fully partitioned area. This method is overridden by derived classes to implement the actual image processing. Note that the sniffer can be ignored if it is certain that a processing task will complete very quickly. This method should never be called directly but rather accessed via Process. There is no allocator parameter as all allocation should be done in Start.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadIndex</td><td>0 to threadCount - 1 index indicating which thread this is. (Can be used to get a thread-specific buffer allocated in the Start method.) </td></tr>
    <tr><td class="paramname">tile</td><td>Area to process. </td></tr>
    <tr><td class="paramname">sniffer</td><td><a class="el" href="classdng__abort__sniffer.html" title="Class for signaling user cancellation and receiving progress updates.">dng_abort_sniffer</a> to use to check for user cancellation </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdng__encode__proxy__task.html#af41f70e8153ccf9ecdb1e0c41ee91091">dng_encode_proxy_task</a>, <a class="el" href="classdng__find__new__raw__image__digest__task.html#ae6943accf1489b06fcfa778e005d601c">dng_find_new_raw_image_digest_task</a>, <a class="el" href="classdng__write__tiles__task.html#ac21585c70f99c02016aa64505d99056d">dng_write_tiles_task</a>, <a class="el" href="classdng__linearize__image.html#a3bce3a533ebbf8aa0a6fc6785bc7bda5">dng_linearize_image</a>, <a class="el" href="classdng__limit__float__depth__task.html#acd692f53952fcf83088ec84cabd9b344">dng_limit_float_depth_task&lt; simd &gt;</a>, <a class="el" href="classdng__inplace__opcode__task.html#a1c8221ff01d069d1577b60c8152c2f0d">dng_inplace_opcode_task</a>, <a class="el" href="classdng__jpeg__image__find__digest__task.html#ab11b3a831213a4f7f72b20e684fb9e6d">dng_jpeg_image_find_digest_task</a>, <a class="el" href="classdng__read__tiles__task.html#a4ce0ffb1dde17f431feb945cbb2fe0ac">dng_read_tiles_task</a>, <a class="el" href="classdng__filter__task.html#ac36eb01a3fbf8603046f62ede387b5a6">dng_filter_task</a>, and <a class="el" href="classdng__jpeg__image__encode__task.html#a09e8365d6a446e771b151ec2ede8bed0">dng_jpeg_image_encode_task</a>.</p>

<p class="reference">Referenced by <a class="el" href="classdng__area__task.html#af80c05689fff8d30091454a4aa1aaec5">ProcessOnThread()</a>.</p>

</div>
</div>
<a id="af80c05689fff8d30091454a4aa1aaec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80c05689fff8d30091454a4aa1aaec5">&#9670;&nbsp;</a></span>ProcessOnThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dng_area_task::ProcessOnThread </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>threadIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdng__rect.html">dng_rect</a> &amp;&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdng__point.html">dng_point</a> &amp;&#160;</td>
          <td class="paramname"><em>tileSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdng__abort__sniffer.html">dng_abort_sniffer</a> *&#160;</td>
          <td class="paramname"><em>sniffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdng__area__task__progress.html">dng_area_task_progress</a> *&#160;</td>
          <td class="paramname"><em>progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle one resource's worth of partitioned tiles. Called after thread partitioning has already been done. Area may be further subdivided to handle maximum tile size, etc. It will be rare to override this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadIndex</td><td>0 to threadCount - 1 index indicating which thread this is. </td></tr>
    <tr><td class="paramname">area</td><td>Tile area partitioned to this resource. </td></tr>
    <tr><td class="paramname">tileSize</td><td>size of tiles to use for processing. </td></tr>
    <tr><td class="paramname">sniffer</td><td><a class="el" href="classdng__abort__sniffer.html" title="Class for signaling user cancellation and receiving progress updates.">dng_abort_sniffer</a> to use to check for user cancellation and progress updates. </td></tr>
    <tr><td class="paramname">progress</td><td>optional pointer to progress reporting object. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classdng__area__task.html#a72270e63cb2e5f4f685493adad00fe6e">MakeTileIterator()</a>, <a class="el" href="classdng__area__task.html#aff21f0bc38f2833cf61e248ee884cec8">Process()</a>, <a class="el" href="classdng__area__task.html#ac347313703dc676464a3935523184ebe">RepeatingTile1()</a>, <a class="el" href="classdng__area__task.html#a8b8eaedd070231b36853df5ce10e4915">RepeatingTile2()</a>, <a class="el" href="classdng__area__task.html#aa689944fe7e197b396eceac13d835b6a">RepeatingTile3()</a>, and <a class="el" href="classdng__abort__sniffer.html#a8da5b4f856d61622c177ca5fe9bb36d7">dng_abort_sniffer::SniffForAbort()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classdng__area__task.html#ab3b8c2eb594436fa36f8e0d36b549ed2">Perform()</a>.</p>

</div>
</div>
<a id="ac347313703dc676464a3935523184ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac347313703dc676464a3935523184ebe">&#9670;&nbsp;</a></span>RepeatingTile1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdng__rect.html">dng_rect</a> dng_area_task::RepeatingTile1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Getter for RepeatingTile1. RepeatingTile1, RepeatingTile2, and RepeatingTile3 are used to establish a set of 0 to 3 tile patterns for which the resulting partitions that the final Process method is called on will not cross tile boundaries in any of the tile patterns. This can be used for a processing routine that needs to read from two tiles and write to a third such that all the tiles are aligned and sized in a certain way. A RepeatingTile value is valid if it is non-empty. Higher numbered RepeatingTile patterns are only used if all lower ones are non-empty. A RepeatingTile pattern must be a multiple of UnitCell in size for all constraints of the partitionerr to be met. </p>

<p>Reimplemented in <a class="el" href="classdng__encode__proxy__task.html#a6bfe0fe1c4d0b86a6ca46d33a9351863">dng_encode_proxy_task</a>, <a class="el" href="classdng__linearize__image.html#aa21c4801f94f07e34de32061c83e3497">dng_linearize_image</a>, and <a class="el" href="classdng__limit__float__depth__task.html#a2b4b94e7c17a30cd39fffc4022ec3540">dng_limit_float_depth_task&lt; simd &gt;</a>.</p>

<p class="reference">Referenced by <a class="el" href="classdng__area__task.html#a94898e6c62176efdd6b3819894368ce4">FindTileSize()</a>, and <a class="el" href="classdng__area__task.html#af80c05689fff8d30091454a4aa1aaec5">ProcessOnThread()</a>.</p>

</div>
</div>
<a id="a8b8eaedd070231b36853df5ce10e4915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8eaedd070231b36853df5ce10e4915">&#9670;&nbsp;</a></span>RepeatingTile2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdng__rect.html">dng_rect</a> dng_area_task::RepeatingTile2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Getter for RepeatingTile2. RepeatingTile1, RepeatingTile2, and RepeatingTile3 are used to establish a set of 0 to 3 tile patterns for which the resulting partitions that the final Process method is called on will not cross tile boundaries in any of the tile patterns. This can be used for a processing routine that needs to read from two tiles and write to a third such that all the tiles are aligned and sized in a certain way. A RepeatingTile value is valid if it is non-empty. Higher numbered RepeatingTile patterns are only used if all lower ones are non-empty. A RepeatingTile pattern must be a multiple of UnitCell in size for all constraints of the partitionerr to be met. </p>

<p>Reimplemented in <a class="el" href="classdng__encode__proxy__task.html#af153ec5426fef7296972b84e09f134f2">dng_encode_proxy_task</a>, <a class="el" href="classdng__linearize__image.html#af7baf913c9b509c3cb4f4b2d5f622387">dng_linearize_image</a>, and <a class="el" href="classdng__limit__float__depth__task.html#a2070a2452b0b5bdba316a631da0b3659">dng_limit_float_depth_task&lt; simd &gt;</a>.</p>

<p class="reference">Referenced by <a class="el" href="classdng__area__task.html#a94898e6c62176efdd6b3819894368ce4">FindTileSize()</a>, and <a class="el" href="classdng__area__task.html#af80c05689fff8d30091454a4aa1aaec5">ProcessOnThread()</a>.</p>

</div>
</div>
<a id="aa689944fe7e197b396eceac13d835b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa689944fe7e197b396eceac13d835b6a">&#9670;&nbsp;</a></span>RepeatingTile3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdng__rect.html">dng_rect</a> dng_area_task::RepeatingTile3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Getter for RepeatingTile3. RepeatingTile1, RepeatingTile2, and RepeatingTile3 are used to establish a set of 0 to 3 tile patterns for which the resulting partitions that the final Process method is called on will not cross tile boundaries in any of the tile patterns. This can be used for a processing routine that needs to read from two tiles and write to a third such that all the tiles are aligned and sized in a certain way. A RepeatingTile value is valid if it is non-empty. Higher numbered RepeatingTile patterns are only used if all lower ones are non-empty. A RepeatingTile pattern must be a multiple of UnitCell in size for all constraints of the partitionerr to be met. </p>

<p class="reference">Referenced by <a class="el" href="classdng__area__task.html#a94898e6c62176efdd6b3819894368ce4">FindTileSize()</a>, and <a class="el" href="classdng__area__task.html#af80c05689fff8d30091454a4aa1aaec5">ProcessOnThread()</a>.</p>

</div>
</div>
<a id="ac8e8c7891745cbe4e6a84600cd4304d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e8c7891745cbe4e6a84600cd4304d5">&#9670;&nbsp;</a></span>Start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dng_area_task::Start </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>threadCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdng__rect.html">dng_rect</a> &amp;&#160;</td>
          <td class="paramname"><em>dstArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdng__point.html">dng_point</a> &amp;&#160;</td>
          <td class="paramname"><em>tileSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdng__memory__allocator.html">dng_memory_allocator</a> *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdng__abort__sniffer.html">dng_abort_sniffer</a> *&#160;</td>
          <td class="paramname"><em>sniffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Task startup method called before any processing is done on partitions. The Start method is called before any processing is done and can be overridden to allocate temporary buffers, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadCount</td><td>Total number of threads that will be used for processing. Less than or equal to MaxThreads. </td></tr>
    <tr><td class="paramname">dstArea</td><td>Area to be processed in the current run of the task. </td></tr>
    <tr><td class="paramname">tileSize</td><td>Size of source tiles which will be processed. (Not all tiles will be this size due to edge conditions.) </td></tr>
    <tr><td class="paramname">allocator</td><td><a class="el" href="classdng__memory__allocator.html" title="Interface for dng_memory_block allocator.">dng_memory_allocator</a> to use for allocating temporary buffers, etc. </td></tr>
    <tr><td class="paramname">sniffer</td><td>Sniffer to test for user cancellation and to set up progress. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classdng__find__new__raw__image__digest__task.html#ab1fa9c6e71b886475c3223d4c70310a5">dng_find_new_raw_image_digest_task</a>, <a class="el" href="classdng__render__task.html#a6d71c29543db9d17d6577e254240cbdf">dng_render_task</a>, <a class="el" href="classdng__resample__task.html#a14aec1689259d576df972758156c141e">dng_resample_task</a>, <a class="el" href="classdng__inplace__opcode__task.html#ae51835f2a0cbed4dd041426ffae6ab5d">dng_inplace_opcode_task</a>, <a class="el" href="classdng__filter__opcode__task.html#a114d4b6c9e08388b4d88cf74f1f7672f">dng_filter_opcode_task</a>, and <a class="el" href="classdng__filter__task.html#a697fa0f424b5b7ead4bbbb2e2dd91f68">dng_filter_task</a>.</p>

<p class="reference">Referenced by <a class="el" href="classdng__area__task.html#ab3b8c2eb594436fa36f8e0d36b549ed2">Perform()</a>.</p>

</div>
</div>
<a id="a8112e046329c15ebe82b88d11c407575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8112e046329c15ebe82b88d11c407575">&#9670;&nbsp;</a></span>UnitCell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdng__point.html">dng_point</a> dng_area_task::UnitCell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Getter for dimensions of which partitioned tiles should be a multiple. Various methods of processing prefer certain alignments. The partitioning attempts to construct tiles such that the sizes are a multiple of the dimensions of this point.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">a</td><td>point giving preferred alignment in x and y </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classdng__area__task.html#a94898e6c62176efdd6b3819894368ce4">FindTileSize()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="dng__area__task_8h_source.html">dng_area_task.h</a></li>
<li>dng_area_task.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
